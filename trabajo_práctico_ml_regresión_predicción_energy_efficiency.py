# -*- coding: utf-8 -*-
"""Grupo 3"""
"""Trabajo Práctico ML - Regresión - Predicción - Energy Efficiency.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ePkovQrRZR7dj6WKNIyjTta0ITIETXdP

# Trabajo Práctico ML - Regresión Lineal - Predicción - Eficiencia Energética

---

Este dataset lo obtuvimos del repositorio de aprendizaje automático de UCI.
https://archive.ics.uci.edu/ml/datasets/energy+efficiency

Este estudio analizó la evaluación de los requisitos de carga de calefacción y carga de refrigeración de los edificios (es decir, la eficiencia energética) en función de los parámetros del edificio.

Realizamos análisis energéticos utilizando 12 formas de edificios diferentes. Los edificios se diferencian en cuanto a la superficie acristalada, la distribución de la superficie acristalada y la orientación, entre otros parámetros.

Features:
- Relative_Compactness
- Surface_Area
- Wall_Area
- Roof_Area
- Overall_Height
- Orientation
- Glazing_Area
- Glazing_Area_Distribution

Predict:
Heating_Load
Cooling_Load

# Contenido Teórico y Práctico para Desarrollo del Trabajo Práctico

**Importación Librerías**
"""

import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split

# LINK SKLEARN LINEAR REGRESSION: https://scikit-learn.org/stable/search.html?q=linear+regression

"""**Carga Dataset**"""

dataset = pd.read_csv('03_Energy-Efficiency_Dataset.csv')

"""**Análisis Dataset**"""

print('ENERGY EFFICIENCY DATASET - HEAD: \n', dataset.head(5))

print('ENERGY EFFICIENCY DATASET - SHAPE: ', dataset.shape)

print('ENERGY EFFICIENCY DATASET - INFO: \n', dataset.info())

print('ENERGY EFFICIENCY DATASET - STATISTICS: \n', dataset.describe())

"""**Análisis Datos**

Coeficientes Correlación (Ver referencia: [correlation matrix](https://www.geeksforgeeks.org/create-a-correlation-matrix-using-python/))
Un coeficiente de correlación (normalmente denominado r) es un número único que describe el alcance de la relación lineal entre dos variables. Un valor de +1 indica una linealidad perfecta (las dos variables se mueven juntas, como "altura en pulgadas" y "altura en centímetros"). Un valor de r = 0 indica que no hay correlación (las variables son independientes) y r = -1 indica que las variables están inversamente correlacionadas (un aumento en una variable se asocia con una disminución en la otra).
"""

cormat = dataset.corr()
print('ENERGY EFFICIENCY DATASET - CORRELATION MATRIX: \n', round(cormat,2))
sns.heatmap(cormat);

"""Visualización de Relación Lineal entre Pares de Features"""

sns.pairplot(dataset[[
'Relative_Compactness',
'Surface_Area',
'Wall_Area',
'Roof_Area',
'Overall_Height',
'Orientation',
'Glazing_Area',
'Glazing_Area_Distribution',
'Heating_Load',
'Cooling_Load',
 ]]);

"""Otra técnica utilizada para identificar relación entre features para seleccionar las más relevantes podemos investigar [mutual_info de scikit learn](https://scikit-learn.org/stable/modules/generated/sklearn.feature_selection.mutual_info_regression.html#sklearn.feature_selection.mutual_info_regression) y [ejemplo](https://guhanesvar.medium.com/feature-selection-based-on-mutual-information-gain-for-classification-and-regression-d0f86ea5262a)"""

x = dataset.drop(labels=['Heating_Load','Cooling_Load'], axis=1)
x

y = dataset['Heating_Load']
y

x_train_features, x_test_features, y_train_features, y_test_features = train_test_split(x, y, test_size=0.2, random_state=0, shuffle=True)

from sklearn.feature_selection import mutual_info_regression
mutual_info = mutual_info_regression(x_train_features, y_train_features)
print('ENERGY EFFICIENCY DATASET - FEATURE COLS - MUTUAL INFO: \n', mutual_info)

mutual_info = pd.Series(mutual_info)
mutual_info.index = x_train_features.columns
mutual_info.sort_values(ascending=False)

mutual_info.sort_values(ascending=False).plot.bar(figsize=(15,5))

"""**Determinación Features Cols**"""

feature_cols = [
'Relative_Compactness',
'Surface_Area',
'Wall_Area']
x = dataset[feature_cols]
print('ENERGY EFFICIENCY DATASET - X (FEATURES COLS): \n', x)
y = dataset.Heating_Load
print('ENERGY EFFICIENCY DATASET - Y (PREDICTION LABEL): \n', y)

"""**Separación Set de Datos**"""

set_test_size = 0.2

x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=set_test_size, random_state=0, shuffle=True)

x_train = x_train.values

x_train

y_train = y_train.values

x_test = x_test.values

x_test

y_test = y_test.values

"""**Definición Modelo**"""

regressor = LinearRegression()

"""**Entrenamiento Modelo**"""

regressor.fit(x_train, y_train)

"""**Predicción Resultados**"""

y_pred = regressor.predict(x_test)

print('ENERGY EFFICIENCY DATASET - Y PREDICTIONS: \n', y_pred)

"""**Evaluación Modelo**"""

from sklearn.metrics import mean_squared_error

"""Mean Squared Error (Ver referencia: [mean_squared_error](https://scikit-learn.org/stable/modules/generated/sklearn.metrics.mean_squared_error.html))"""

print('ENERGY EFFICIENCY DATASET - MEAN SQUARED ERROR: ', mean_squared_error(y_test, y_pred))

"""Coeficientes Regressor (Ver referencia: [regressor.coef_ property](https://scikit-learn.org/stable/tutorial/statistical_inference/supervised_learning.html#linear-regression))"""

regressor.coef_

"""Score de Evaluación"""

regressor.score(x_test, y_test)

"""Ver ejemplo para balancear dataset"""

from imblearn.over_sampling import RandomOverSampler
from collections import Counter
over_sampler = RandomOverSampler(random_state=42)
x_res_over_sampler, y_res_over_sampler = over_sampler.fit_resample(x_train, y_train)
print(f"Training target statistics: {Counter(y_res_over_sampler)}")
print(f"Testing target statistics: {Counter(y_test)}")
classes = y_res_over_sampler
unique, counts = np.unique(classes, return_counts=True)
plt.bar(unique,counts)
plt.title('Class Frequency')
plt.xlabel('Class')
plt.ylabel('Frequency')
plt.show()
from imblearn.under_sampling import RandomUnderSampler
under_sampler = RandomUnderSampler(random_state=42)
x_res_under_sampler, y_res_under_sampler = under_sampler.fit_resample(x_train, y_train)
print(f"Training target statistics: {Counter(y_res)}")
print(f"Testing target statistics: {Counter(y_test)}")
classes = y_res_under_sampler
unique, counts = np.unique(classes, return_counts=True)
plt.bar(unique,counts)
plt.title('Class Frequency')
plt.xlabel('Class')
plt.ylabel('Frequency')
plt.show()